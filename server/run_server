#!/usr/bin/python3

import http.server
import socketserver
import sys
import ctypes
from dataclasses import dataclass, field
import uuid

from urllib.parse import urlparse, unquote_to_bytes, unquote


class C_networkfs_dir_entry(ctypes.Structure):
    _fields_ = [
        ("entry_type", ctypes.c_ubyte),
        ("ino", ctypes.c_uint64),
        ("name", ctypes.c_char * 256)
    ]

class C_networkfs_dir_entries(ctypes.Structure):
    _fields_ = [
        ("entries_count", ctypes.c_uint64),
        ("entries", C_networkfs_dir_entry * 16)
    ]

class C_networkfs_entry_info(ctypes.Structure):
    _fields_ = [
        ("entry_type", ctypes.c_ubyte),
        ("ino", ctypes.c_uint64)
    ]


ROOT_INO = 1000
MAX_ENTRIES = 16
MAX_FILESZ = 512
MAX_FILENAME_LEN = 255

DT_DIR = 4
DT_REG = 8

SUCCESS = 0
ERR_INODE_NOT_FOUND = 1
ERR_NOT_A_FILE = 2
ERR_NOT_A_DIR = 3
ERR_NO_ENTRY = 4
ERR_ENTRY_EXISTS = 5
ERR_MAX_FILE_SIZE = 6
ERR_MAX_NUM_ENTRIES = 7
ERR_DIR_NOT_EMPTY = 8
ERR_MAX_FILENAME_LEN = 9

@dataclass
class Inode:
    ty: int
    ino: int
    n_links: int = 1
    content: bytes = field(default_factory=lambda: b"")

@dataclass
class Dentry:
    inode: Inode
    entries: dict[str, "Dentry"] = field(default_factory=dict)

@dataclass
class Bucket:
    max_ino: int = ROOT_INO
    inodes: dict[int, Inode] = field(default_factory=dict)
    dirs: dict[int, Dentry] = field(default_factory=dict)

    def get_free_ino(self) -> int:
        ret = self.max_ino
        self.max_ino += 1
        return ret

    def initfs(self) -> None:
        root_dir = Dentry(Inode(DT_DIR, self.get_free_ino()))
        self.inodes[ROOT_INO] = root_dir.inode
        self.dirs[ROOT_INO] = root_dir
        file1 = self.create_new(root_dir, 'file1', DT_REG)
        file1.inode.content = "hello world from file1".encode('ascii')
        self.create_new(root_dir, 'file2', DT_REG)

    def create_new(self, parent: Dentry, name: str, ty: int) -> Dentry:
        newent = Dentry(Inode(ty, self.get_free_ino()))
        parent.entries[name] = newent
        self.inodes[newent.inode.ino] = newent.inode
        if newent.inode.ty == DT_DIR:
            self.dirs[newent.inode.ino] = newent
        return newent
    
    def link(self, source: Inode, parent: Dentry, name: str) -> Dentry:
        newlink = Dentry(source)
        parent.entries[name] = newlink
        source.n_links += 1
        return newlink
    
    def unlink(self, parent_dir: Dentry, name: str) -> None:
        inode = parent_dir.entries[name].inode
        del parent_dir.entries[name]
        if inode.ty == DT_DIR:
            del self.dirs[inode.ino]
        inode.n_links -= 1
        if inode.n_links == 0:
            del self.inodes[inode.ino]

BUCKETS: dict[str, Bucket] = {}




def token_issue() -> tuple[int, bytes]:
    uid = str(uuid.uuid4())
    bucket = Bucket()
    bucket.initfs()
    BUCKETS[uid] = bucket
    return SUCCESS, uid.encode('ascii')


def fs_list(bucket: Bucket, ino: int) -> tuple[int, bytes]:
    if not bucket.inodes.get(ino):
        return ERR_INODE_NOT_FOUND, None
    if not (dir := bucket.dirs.get(ino)):
        return ERR_NOT_A_DIR, None
    c_entries = (C_networkfs_dir_entry * 16)()
    for i, (name, entry) in enumerate(dir.entries.items()):
        name_enc = name.encode('ascii')
        c_entries[i] = C_networkfs_dir_entry(
            entry_type=entry.inode.ty, 
            ino=entry.inode.ino, 
            name= name_enc + b"\x00" * (256 - len(name_enc)) 
        )
    
    return SUCCESS, bytes(C_networkfs_dir_entries(entries_count=len(dir.entries), entries=c_entries))

def fs_create(bucket: Bucket, parent_ino: int, name: str, ty: str) -> tuple[int, bytes]:
    if not bucket.inodes.get(parent_ino):
        return ERR_INODE_NOT_FOUND, None
    if not (parent_dir := bucket.dirs.get(parent_ino)):
        return ERR_NOT_A_DIR, None
    if name in parent_dir.entries.keys():
        return ERR_ENTRY_EXISTS, None
    if len(parent_dir.entries) == MAX_ENTRIES:
        return ERR_MAX_NUM_ENTRIES, None
    if len(name) > MAX_FILENAME_LEN:
        return ERR_MAX_FILENAME_LEN, None
    if ty == 'directory':
        ino = bucket.create_new(parent_dir, name, DT_DIR).inode.ino
    elif ty == 'file':
        ino = bucket.create_new(parent_dir, name, DT_REG).inode.ino
    else:
        raise RuntimeError("fs_create: Unknown type")
    return SUCCESS, bytes(ctypes.c_uint64(ino))

def fs_read(bucket: Bucket, ino: int) -> tuple[int, bytes]:
    if not (inode := bucket.inodes.get(ino)):
        return ERR_INODE_NOT_FOUND, None
    if bucket.dirs.get(ino):
        return ERR_NOT_A_FILE, None
    return SUCCESS, bytes(ctypes.c_uint64(len(inode.content))) + inode.content

def fs_write(bucket: Bucket, ino: int, content: bytes) -> tuple[int, bytes]:
    if not (inode := bucket.inodes.get(ino)):
        return ERR_INODE_NOT_FOUND, None
    if bucket.dirs.get(ino):
        return ERR_NOT_A_FILE, None
    if len(content) > MAX_FILESZ:
        return ERR_MAX_FILE_SIZE, None
    inode.content = content
    return SUCCESS, None

def fs_link(bucket: Bucket, source_ino: int, parent_dir_ino: str, link_name: str) -> tuple[int, bytes]:
    if not (source := bucket.inodes.get(source_ino)) or not bucket.inodes.get(parent_dir_ino):
        return ERR_INODE_NOT_FOUND, None
    if bucket.dirs.get(source_ino):
        return ERR_NOT_A_FILE, None
    if not (parent_dir := bucket.dirs.get(parent_dir_ino)):
        return ERR_NOT_A_DIR, None
    if link_name in parent_dir.entries.keys():
        return ERR_ENTRY_EXISTS, None
    if len(parent_dir.entries) == MAX_ENTRIES:
        return ERR_MAX_NUM_ENTRIES, None
    bucket.link(source, parent_dir, link_name)
    return SUCCESS, None

def fs_unlink(bucket: Bucket, parent_dir_ino: int, name : str) -> tuple[int, bytes]:
    if not bucket.inodes.get(parent_dir_ino):
        return ERR_INODE_NOT_FOUND, None
    if not (parent_dir := bucket.dirs.get(parent_dir_ino)):
        return ERR_NOT_A_DIR, None
    if not (target_ent := parent_dir.entries.get(name)):
        return ERR_NO_ENTRY, None 
    if bucket.dirs.get(target_ent.inode.ino):
        return ERR_NOT_A_FILE, None
    bucket.unlink(parent_dir, name)
    return SUCCESS, None

def fs_rmdir(bucket: Bucket, parent_dir_ino: int, name : int) -> tuple[int, bytes]:
    if not bucket.inodes.get(parent_dir_ino):
        return ERR_INODE_NOT_FOUND, None
    if not (parent_dir := bucket.dirs.get(parent_dir_ino)):
        return ERR_NOT_A_DIR, None
    if not (target_ent := parent_dir.entries.get(name)):
        return ERR_NO_ENTRY, None
    if not target_ent.inode.ty == DT_DIR:
        return ERR_NOT_A_DIR, None
    if len(target_ent.entries) != 0:
        return ERR_DIR_NOT_EMPTY, None
    bucket.unlink(parent_dir, name)
    return SUCCESS, None

def fs_lookup(bucket: Bucket, parent_dir_ino: int, name : int) -> tuple[int, bytes]:
    if not bucket.inodes.get(parent_dir_ino):
        return ERR_INODE_NOT_FOUND, None
    if not (parent_dir := bucket.dirs.get(parent_dir_ino)):
        return ERR_NOT_A_DIR, None
    if not (target_ent := parent_dir.entries.get(name)):
        return ERR_NO_ENTRY, None
    return SUCCESS, bytes(C_networkfs_entry_info(entry_type=target_ent.inode.ty, ino=target_ent.inode.ino))


class NetworkfsRequestHandler(http.server.SimpleHTTPRequestHandler):
    BINARY_QUERY_PARAMS = {'content'}

    @staticmethod
    def create_response_body(code: int, response: bytes) -> bytes:
        res = bytes(ctypes.c_uint64(code))
        return res + response if response else res

    @staticmethod
    def parse_query_params(qs: str) -> dict:
        from collections import defaultdict

        if not qs:
            return dict()
        parts = qs.split('&')
        res = defaultdict(list)
        for part in parts:
            param_name, param_val = part.split('=')
            if param_name in NetworkfsRequestHandler.BINARY_QUERY_PARAMS:
                res[param_name].append(unquote_to_bytes(param_val))
            else:
                res[param_name].append(unquote(param_val, encoding='utf-8', errors='strict'))
        return dict(res)
    
    def do_GET(self):
        print(f"--- Incoming GET Request ---")

        parsed_url = urlparse(self.path)
        path = parsed_url.path
        query_params = self.parse_query_params(parsed_url.query)
        print(f"Path: {path}")
        print(f"Params: {query_params}")
        print(f"Headers:\n{self.headers}")

        if (not path.startswith('/networkfs/')):
            self.send_error(400)
            return
        path_splitted = path.split('/')[2:]
        status = None
        response = None
        if len(path_splitted) == 2:
            pref, op = path_splitted
            if pref == 'token':
                if op == 'issue':
                    status, response = token_issue()
                else:
                    self.send_error(400)
                    return
            else:
                self.send_error(400)
                return
        elif len(path_splitted) == 3:
            token, pref, op = path_splitted
            if not (bucket := BUCKETS.get(token)):
                self.send_error(400)
                return
            if pref == 'fs':
                if op == 'list':
                    status, response = fs_list(bucket, ino=int(query_params['inode'][0]))
                elif op == 'create':
                    status, response = fs_create(
                        bucket, 
                        parent_ino=int(query_params['parent'][0]),
                        name=query_params['name'][0],
                        ty=query_params['type'][0])
                elif op == 'read':
                    status, response = fs_read(bucket, ino=int(query_params['inode'][0]))
                elif op == 'write':
                    status, response = fs_write(
                        bucket, 
                        ino=int(query_params['inode'][0]),
                        content=query_params['content'][0])
                elif op == 'link':
                    status, response = fs_link(
                        bucket,
                        source_ino=int(query_params['source'][0]),
                        parent_dir_ino=int(query_params['parent'][0]),
                        link_name=query_params['name'][0])
                elif op == 'unlink':
                    status, response = fs_unlink(
                        bucket,
                        parent_dir_ino=int(query_params['parent'][0]),
                        name=query_params['name'][0])
                elif op == 'rmdir':
                    status, response = fs_rmdir(
                        bucket,
                        parent_dir_ino=int(query_params['parent'][0]),
                        name=query_params['name'][0])
                elif op == 'lookup':
                    status, response = fs_lookup(
                        bucket,
                        parent_dir_ino=int(query_params['parent'][0]),
                        name=query_params['name'][0])
                else:
                    self.send_error(400)
                    return
        else:
            self.send_error(400)
            return

        response_body = self.create_response_body(status, response)
        self.send_response(200)
        self.send_header("Content-Length", str(len(response_body)))
        self.end_headers()
        self.wfile.write(response_body)

def run_server(port):
    server_address = ('127.0.0.1', port)
    
    with socketserver.TCPServer(server_address, NetworkfsRequestHandler) as httpd:
        print(f"Networkfs server listening on {server_address[0]} port {port}...")
        try:
            httpd.serve_forever()
        except KeyboardInterrupt:
            print("\nServer stopped.")
            httpd.server_close()

if __name__ == "__main__":
    if len(sys.argv) == 2:
        try:
            port = int(sys.argv[1])
            run_server(port)
        except ValueError:
            print(f"Error: Invalid port number '{sys.argv[1]}'. Must be an integer.")
            sys.exit(1)
    else:
        print(f"Usage: {sys.argv[0]} <port_number>")
        sys.exit(1)
